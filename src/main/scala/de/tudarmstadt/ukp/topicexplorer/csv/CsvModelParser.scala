/*******************************************************************************
 * Copyright 2016
 * Ubiquitous Knowledge Processing (UKP) Lab
 * Technische UniversitÃ¤t Darmstadt
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/
package de.tudarmstadt.ukp.topicexplorer.csv

import java.io.File

import de.tudarmstadt.ukp.topicexplorer.Util
import org.slf4j.{Logger, LoggerFactory}

/**
  * Represents a topic with an optional alpha value and token-count pairs in the form ('token':String, 'count':Int).
  *
  * @param alpha       the topic's alpha value (optional)
  * @param tokenCounts a sequence of ('token', 'count') pairs
  */
case class Topic(alpha: Option[Float], tokenCounts: Seq[(String, Int)])

/**
  * A parser for model files in the form of CSV (or TSV) files, generated by [[de.tudarmstadt.ukp.topicexplorer.mallet.MalletModelConverter]].
  */
class CsvModelParser(modelFile: File, columnSeparator: Char = '\t') {
  private val LOGGER: Logger = LoggerFactory.getLogger(classOf[CsvModelParser])
  require(modelFile.canRead, s"Cannot read file '$modelFile'.")

  /**
    * Queries for a string, comprising one or multiple tokens (separated by whitespace).
    *
    * @param input a query string in the form 'token1[ token2 ...]
    * @return a string for the full output
    */
  def query(input: String): String = query(input.split("\\s+").map(_.trim()))

  /**
    * Queries for a sequence of query tokens.
    *
    * @param tokens a sequence of query tokens
    * @return a string for the full output
    */
  def query(tokens: Seq[String]): String = {
    val lines = findLines(tokens)
    output(lines.toSeq, tokens)
  }

  /**
    * Retrieves topic lines in the input file that have at least one occurrence assigned to all of the input tokens.
    *
    * @param queryTokens a sequence of query token strings
    * @return an iterator over the matching [[de.tudarmstadt.ukp.topicexplorer.csv.Topic]]s
    */
  def findLines(queryTokens: Seq[String]): Iterator[Topic] = {
    LOGGER.info("Reading file " + modelFile)
    io.Source.fromFile(modelFile).getLines()
      .map(parseLine(_, queryTokens = queryTokens)) // map lines to Topics
      .withFilter(findTokens(_, queryTokens).forall(_._2 > 0)) // obtain lines in which all the query tokens occurred
  }

  /**
    * Returns a pair of topic's alpha value if available (in first column), and a sequence of pairs
    * representing tokens and respective counts.
    * <p>
    * The resulting [[de.tudarmstadt.ukp.topicexplorer.csv.Topic]] holds the top `n` tokens (defined
    * by the `maxToken` parameter, defaulting to 10 plus the tokens which were passed with the
    * `queryTokens` parameters
    *
    * @param line        the input line
    * @param maxTokens   the maximum number of tokens to output (apart from the query)
    * @param queryTokens these tokens are always added to the resulting topic's token sequence, regardless of their count
    * @return a [[de.tudarmstadt.ukp.topicexplorer.csv.Topic]] for the input line
    */
  def parseLine(line: String, maxTokens: Int = 10, queryTokens: Seq[String]): Topic = {
    val columns = line.split(columnSeparator)
    val (alpha, tokens) =
      if (columns.length % 2 == 0) (None, columns) // even number of columns: no alpha value
      else (Some(columns.head.toFloat), columns.tail) // uneven number of columns: first column contains alpha value

    /* the token-count pairs come pre-sorted in the input file */
    val topTokens = tokens.grouped(2)
      .map(a => (a(0), a(1).toFloat.toInt))
      .take(maxTokens)
      .toSeq

    val topic = Topic(alpha, topTokens)

    /* add query tokens */
    Topic(topic.alpha,
      (topic.tokenCounts ++
        findTokens(topic, queryTokens))
        .distinct
        .sortBy(-_._2)
    )
  }

  /**
    * Convert the topics into a single string, ordering the topic by frequency of the queries.
    *
    * @param topics      a list of [[de.tudarmstadt.ukp.topicexplorer.csv.Topic]]s
    * @param queryTokens a sequence of strings representing the query tokens
    * @return a single string
    */
  def output(topics: Seq[Topic], queryTokens: Seq[String]): String = {
    /* count tokens */
    val queryTokenCounts = queryTokens
      .map { token => topics.map(topic => findToken(topic, token))
        .map(_._2)
        .sum
      }
    LOGGER.info(s"Total count for '${queryTokens.mkString(", ")}': ${queryTokenCounts.mkString(", ")}")

    /* generate output string */
    topics
      .sortBy(-harmonicMeanTokenCounts(_, queryTokens))
      .map(topicToString)
      .mkString(System.lineSeparator())
  }

  /**
    * Converts a [[de.tudarmstadt.ukp.topicexplorer.csv.Topic]] into a string
    *
    * @param topic a [[de.tudarmstadt.ukp.topicexplorer.csv.Topic]]
    * @return a string representing the input topic
    */
  def topicToString(topic: Topic): String = {
    val alpha =
      if (topic.alpha.isDefined) s"(${topic.alpha.get.toString})\t"
      else ""
    val tokens = topic.tokenCounts
      .map(pair => s"${pair._1}: ${pair._2}")
      .mkString("\t")
    alpha + tokens
  }

  /**
    * Returns the sum of all query tokens in a topic.
    *
    * @param topic       a [[de.tudarmstadt.ukp.topicexplorer.csv.Topic]]
    * @param queryTokens a sequence of query tokens
    * @return the sum of all query tokens in the topic
    */
  def sumTokenCounts(topic: Topic, queryTokens: Seq[String]): Int =
    findTokens(topic, queryTokens)
      .map(_._2)
      .sum

  /**
    * Return the harmonic mean over the frequency counts for the query tokens in the given topic.
    *
    * Results in 0 if any of the token counts is 0 or if the query tokens sequence is empty.
    *
    * @param topic       a [[de.tudarmstadt.ukp.topicexplorer.csv.Topic]]
    * @param queryTokens the tokens for which to compute the harmonic mean
    * @return the harmonic mean of the query tokens in the topic.
    */
  def harmonicMeanTokenCounts(topic: Topic, queryTokens: Seq[String]): Double =
    Util.harmonicMean(
      findTokens(topic, queryTokens)
        .map(_._2)
    )

  /**
    * Extract the given tokens with counts from a topic
    *
    * @param topic  a [[de.tudarmstadt.ukp.topicexplorer.csv.Topic]]
    * @param tokens a sequence of query tokens
    * @return a sequence of '(token, count)' pairs, one for each input token
    */
  def findTokens(topic: Topic, tokens: Seq[String]): Seq[(String, Int)] =
    tokens.map(findToken(topic, _))

  /**
    * Extract a token with count for a topic. If the token does not occur in the topic, the count
    * is 0.
    *
    * @param topic a [[de.tudarmstadt.ukp.topicexplorer.csv.Topic]]
    * @param token a string
    * @return a pair '(token, count)'
    */
  def findToken(topic: Topic, token: String): (String, Int) =
    topic.tokenCounts
      .find(_._1 == token)
      .getOrElse(token, 0)
}
